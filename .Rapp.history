spawners
recruits
pop
death<-runif(1)<=rnorm(1,ocean_survival_mean,ocean_survival_sd)     #calculate a death probability for each individual
death
death<-vector(length=10000)
death
for(i in 1:length(death)){death[i]<-runif(1)<=rnorm(1,ocean_survival_mean,ocean_survival_sd) }
death
plt(death)
plot(death)
summary(death)
for(i in 1:length(death)){death[i]<-runif(1)>=rnorm(1,ocean_survival_mean,ocean_survival_sd) }
summary(death)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.2                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-5,runif(1)*1e-5)           #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.8#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-2500                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=rnorm(1,ocean_survival_mean,ocean_survival_sd)     #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                #if death, reset alive = 0#
  } else {                                                            #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                  #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
plot(pop)
spawners
recruits
plot(spawners,recruits)
SSS<-seq(0,1e6)
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)
RRR
plot(SSS,RRR)
rm(list=ls())
ls()
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-5,runif(1)*1e-5)           #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-1/ricker_b                              #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
ind
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-5,runif(1)*1e-5)           #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-1/ricker_b                              #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
1/ricker_b
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-5,runif(1)*1e-5)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-0.2*round(1/ricker_b)                       #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-5,runif(1)*1e-5)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-round(0.2*(1/ricker_b))                 #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
rm(list=ls())
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-5,runif(1)*1e-5)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-round(0.2*(1/ricker_b))                 #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
ind
rm(list=ls())
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-5,runif(1)*1e-5)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-2000                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-5,runif(1)*1e-5)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-2000                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
plot(pop)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.1e-3,runif(1)*1e-4)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-2000                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
ricker_b
SSS<-seq(1,1/ricker_b)
SSS
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)
plot(SSS,RRR)
SSS<-seq(1,10*1/ricker_b)
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)
plot(SSS,RRR)
pop
ricker_b<-max(0.1e-3,runif(1)*1e-4)         #Ricker Stock Recruitment Parameters
ricker_b
ricker_b<-max(1e-3,runif(1)*1e-4)         #Ricker Stock Recruitment Parameters
ricker_b
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(1e-3,runif(1)*1e-4)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-2000                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
plot(pop)
ricker_b
SSS<-seq(1,1e6)
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)
plot(SSS,RRR)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(1e-2,runif(1)*1e-3)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-2000                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(1e-2,runif(1)*1e-3)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-2000                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
plot(pop)
plot(pop, ylim=c(0,2000))
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.5e-1,runif(1)*0.5e-2)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-2000                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
pop
plot(pop)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.5e-1,runif(1)*0.5e-2)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt
plot(pop)
plot(pop, ylim=c(0,300))
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-max(0.5e-1,runif(1)*0.5e-2)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-min(0.5e-1,runif(1)*0.5e-2)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
pop
ricker_b
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-min(0.5e-1,runif(1)*1e-2)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
pop
ricker_b
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list-ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-min(0.5e-1,runif(1)*1e-2)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
pop
spawners
recruits
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-min(0.5e-1,runif(1)*1e-2)         #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
pop
clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-500#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters
ricker_b
ricker_a
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-500#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
pop
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-180                                   #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
plot(pop)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-80                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
plot(pop)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-50                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0,300))
plot(pop)
plot(pop, ylim=c(0, (max(pop)+25))
)
plot(pop, ylim=c(0, max(pop)+25))
plot(pop, ylim=c(0, max(pop))
)
max(pop)
plot(pop, ylim=c(0, max(pop[1:100]))
)
plot(pop, ylim=c(0, max(pop[1:100]+25)))
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-30                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0, max(pop[1:100]+25)))
frac.male
recruits
spawners
SSS<-seq(1,1000)
RRR<-ricker_simple(SSS,ricker_a,ricker_b,1)
plot(SSS,RRR)
SSS<-seq(1,200)
RRR<-ricker_simple(SSS,ricker_a,ricker_b,1)
plot(SSS,RRR)
pop
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
 pop[i] <- length(is.alive) #
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0, max(pop[1:100]+25)))
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.zero[i]<-length(is.zero) #
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
frac.male<- NaN * time # fraction of population that is blue#
cols <- sapply(ind, function(x) x$sex)#
frac.male[i]<-sum(cols=="male") / length(cols)#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0, max(pop[1:100]+25)))
t
pop.zero
pop.one
pop.two
pop.three
pop.four
pop
pop.one[1]
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.96#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
plot(pop, ylim=c(0, max(pop[1:100]+25)))
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
lines(pop.zero,color=1)#
lines(pop.one,color=2)#
lines(pop.two,color=3)#
lines(pop.three,color=4)#
lines(pop.four,color=5)
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
lines(pop.zero,col=1)#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)
par(mfcol=c(1,2))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)))#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-0.7                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,2))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(spawners,recruits)
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-5                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
error
plot(density(error))
plot(error, type="h")
spawners
recruits
pop
pop.four
pop.three
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)
pop.zero
recruits
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-100                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-5                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM#
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#idea for list of lists IBM from ningkiling@gmail.com#
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                    #Starting Population#
t<-1000                                      #time of simulation in years#
shared_anomoly<-0.2                         #degree of autocorrelation in recruitment variability#
sd<-5                                     #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
pop
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-5                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
pop
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners,ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
warnings()
error
plot(error)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
plot(pop.four)
plot(pop.four,spawners)
abline(a=1)
abline(a=1,b=0)
abline(a=0,b=1)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-200                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  death<-runif(1)>=min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))  #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.01#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
plot(survivL)
plot(survival)
plot(density(survival))
plot(density(survival[1:100]))
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(1,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)
plot(survival)
plot(density(survival))
plot(density(survival[1:200]))
plot(density(survival[1:t]))
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(density(error[1:t]), main="distribution of survial rates")#
plot(survival[1:t])#
points(error[1:t])
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(density(error[1:t]), main="distribution of survial rates")#
plot(survival[1:t])#
points(error[1:t],col="red")
,
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(density(error[1:t]), main="distribution of survial rates",col="red")#
plot(survival[1:t])#
points(error[1:t],col="red")
?par()
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rates",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(survival[1:t])#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rates",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(survival[1:t], ylim(c-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rates",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-20                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-50                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-200                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-50                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners <- NaN * time # population size#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners[i]<-spawners[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(spawners[i],ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
pop
spawners
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-50                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners.m <- NaN * time # population size#
spawners.f <- NaN * time # population size#
#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners.f[i]<-spawners.f[i]+1#
 }#
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners.m[i]<-spawners.m[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(min(spawners.m[i],spawners.f[i]),ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(spawners,recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-50                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners.m <- NaN * time # population size#
spawners.f <- NaN * time # population size#
#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners.f[i]<-spawners.f[i]+1#
 }#
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners.m[i]<-spawners.m[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(min(spawners.m[i],spawners.f[i]),ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(pmin(spawners.m,spawners.f),recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-50                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners.m <- NaN * time # population size#
spawners.f <- NaN * time # population size#
#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners.f[i]<-spawners.f[i]+1#
 }#
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners.m[i]<-spawners.m[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(min(spawners.m[i],spawners.f[i]),ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(pmin(spawners.m,spawners.f),recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-50                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners.m <- NaN * time # population size#
spawners.f <- NaN * time # population size#
#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners.f[i]<-0#
spawners.m[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners.f[i]<-spawners.f[i]+1#
 }#
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners.m[i]<-spawners.m[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-round(ricker_simple(min(spawners.m[i],spawners.f[i]),ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(pmin(spawners.m,spawners.f),recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
pop
pop.four
recruitment
recruits
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-50                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners.m <- NaN * time # population size#
spawners.f <- NaN * time # population size#
#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners.f[i]<-0#
spawners.m[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners.f[i]<-spawners.f[i]+1#
 }#
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners.m[i]<-spawners.m[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-as.integer(ricker_simple(min(spawners.m[i],spawners.f[i]),ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(pmin(spawners.m,spawners.f),recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
points
pop
recruits
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-150                                    #aproximate spawners to maximize recruits#
#
ricker_a<-1.6                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners.m <- NaN * time # population size#
spawners.f <- NaN * time # population size#
#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners.f[i]<-0#
spawners.m[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners.f[i]<-spawners.f[i]+1#
 }#
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners.m[i]<-spawners.m[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-as.integer(ricker_simple(min(spawners.m[i],spawners.f[i]),ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(pmin(spawners.m,spawners.f),recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-500                                    #aproximate spawners to maximize recruits#
#
ricker_a<-2.1                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.7#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners.m <- NaN * time # population size#
spawners.f <- NaN * time # population size#
#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners.f[i]<-0#
spawners.m[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners.f[i]<-spawners.f[i]+1#
 }#
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners.m[i]<-spawners.m[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-as.integer(ricker_simple(min(spawners.m[i],spawners.f[i]),ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(pmin(spawners.m,spawners.f),recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
POPULATION VIABILITY ANALYSIS for SALMON#
#Nov 13,2013#
#Mike Hawkshaw#
#The idea for list of lists IBM and some neat list handling code from ningkiling@gmail.com #
#http://menugget.blogspot.ca/2013/10/a-first-attempt-at-individual-based.html#
#
#clear the memory#
rm(list=ls())#
#
#Population characteristics#
#run_size_K<-15000                          #Carrying_capacity#
#
s_eq<-500                                    #aproximate spawners to maximize recruits#
#
ricker_a<-2.1                               #Ricker Stock Recruitment Parameters#
ricker_b<-ricker_a/s_eq                     #Ricker Stock Recruitment Parameters#
#
ocean_survival_mean<-0.9#
ocean_survival_sd<-0.05#
#
#Simulation characteristics#
N0<-5*s_eq                                     #Starting Population#
t<-400                                      #time of simulation in years#
shared_anomoly<-0.4                         #degree of autocorrelation in recruitment variability#
sd<-1                                       #recruitment #
#
#SUBFUNCTIONS#
#
#Generate some autocorrelated recruitment anomly#
#
recruitment_anomoly_generator<-function(t,shared_anomoly,sd)#
{#
y<-vector(mode="double",length=t)#
y[1]<-rnorm(1,0,(sd*shared_anomoly))#
#
for (i in 2:t)#
{#
  y[i]<-(1-shared_anomoly)*y[i-1]+shared_anomoly*rnorm(1,0,sd)#
}#
#
output<-y#
return(output)#
}#
#
#Simple Ricker Recruitment Model#
ricker_simple<-function(x,a,b,error)#
{#
#
y<-x*exp(a-b*x+error)#
#
output<-y#
return(output)                                        #
}#
#
###############################################################################
#MAIN Build up the actual IBM##################################################
###############################################################################
#
#create starting individual w attributes ("alive", "age", "sex")#
set.seed(1)#
error<-recruitment_anomoly_generator(t,shared_anomoly,sd)#
ind<-vector(mode="list", N0)#
#
for(j in 1:5)#
{#
  for(i in 1:(N0/5))#
  {#
  ind[[i+((j-1)*N0/5)]]$alive <- 1#
  ind[[i+((j-1)*N0/5)]]$age <-(j-1)#
  ind[[i+((j-1)*N0/5)]]$sex <- c("male", "female")[round(runif(1)+1)]#
  }#
}#
#
#make empty vectors to record population statistics#
time <- seq(t+1)#
pop <- NaN * time # population size#
pop.zero <- NaN * time # population size#
pop.one <- NaN * time # population size#
pop.two <- NaN * time # population size#
pop.three <- NaN * time # population size#
pop.four <- NaN * time # population size#
#
spawners.m <- NaN * time # population size#
spawners.f <- NaN * time # population size#
#
recruits <- NaN * time # population size#
#
survival <- NaN * time # population size#
#
pop[1] <- N0#
#simulation#
save.alive.only <- TRUE # optional cropping of "ind" to include alive individuals only #
t1 <- Sys.time()#
for(i in seq(t)){ # loop for each time increment#
spawners.f[i]<-0#
spawners.m[i]<-0#
is.alive <- which(sapply(ind, function(x) x$alive) == 1)#
#
for(j in is.alive){ #loop for each alive individual#
  if(ind[[j]]$age>=5){#
   ind[[j]]$alive <- 0                                                    #no Sockeye older than 4 years old#
  } #
  if(ind[[j]]$age==4&&ind[[j]]$sex == "female"){#
   spawners.f[i]<-spawners.f[i]+1#
 }#
  if(ind[[j]]$age==4&&ind[[j]]$sex == "male"){#
   spawners.m[i]<-spawners.m[i]+1#
  }#
  survival[i]<-min(1,rnorm(1,ocean_survival_mean,ocean_survival_sd))#
  death<-runif(1)>=survival[i]                                               #calculate a death probability for each individual #
  if(death){#
   ind[[j]]$alive <- 0                                                    #if death, reset alive = 0#
  } else {                                                                #else, advance age + 1#
    ind[[j]]$age <- ind[[j]]$age + 1                                      #advance age of parent#
  }#
 is.alive<-which(sapply(ind, function(x) x$alive) == 1)#
 pop[i]<-length(is.alive) #
 is.zero<-which(sapply(ind[is.alive], function(x) x$age) == 0)#
 is.one<-which(sapply(ind[is.alive], function(x) x$age) == 1)#
 is.two<-which(sapply(ind[is.alive], function(x) x$age) == 2)#
 is.three<-which(sapply(ind[is.alive], function(x) x$age) == 3)#
 is.four<-which(sapply(ind[is.alive], function(x) x$age) == 4)#
#
 pop.one[i]<-length(is.one) #
 pop.two[i]<-length(is.two) #
 pop.three[i]<-length(is.three) #
 pop.four[i]<-length(is.four) #
#
 recruits[i]<-as.integer(ricker_simple(min(spawners.m[i],spawners.f[i]),ricker_a,ricker_b,error[i]))#
 pop.zero[i]<-recruits[i]#
}#
  births<-recruits[i]#
  len.ind <- length(ind)#
  for(i in 1:births){#
  ind[[len.ind+i]] <- list(alive=1, age=0, sex=c("male", "female")[round(runif(1)+1)]) # create offspring, inherits color of parent#
  } #
#
 #optional cropping of list "ind"#
 if(save.alive.only){#
  is.dead <- which(sapply(ind, function(x) x$alive) == 0)#
  if(length(is.dead) > 0) ind <- ind[-is.dead]#
 }#
}#
t2 <- Sys.time()#
dt <- t2-t1#
dt#
#
par(mfcol=c(2,3))#
plot(pop, ylim=c(0, max(pop[1:100]+25)))#
plot(density(survival[1:t]), main="distribution of survial rates")#
plot(pop.zero,col=1,ylim=c(0, max(pop.zero[1:100]+10)), type="l")#
lines(pop.one,col=2)#
lines(pop.two,col=3)#
lines(pop.three,col=4)#
lines(pop.four,col=5)#
plot(density(error[1:t]), main="distribution of survial rec anomolies",col="red")#
#
SSS<-seq(1,max(pop.four[1:100]))#
RRR<-ricker_simple(SSS,ricker_a,ricker_b,0)#
plot(SSS,RRR, type="l",lwd=2)#
points(pmin(spawners.m,spawners.f),recruits)#
#
plot(survival[1:t], ylim=c(-2,2))#
points(error[1:t],col="red")
pop
set.seed(999)												#all use same random numbers#
setwd("/Users/mikehawkshaw/Desktop/Fish_505_Example/Fish_505")			#it makes reading and writing files easier if you're in the right directory										#set a working directory#
##########################################################################################################
#Sub Functions#
##########################################################################################################
#Dynamics - Subs#
#
#RICKER REC SUB#
ricker_simple<-function(x,a,b,proc_error)				#a function to calculate the return associated with any spawning stock size #
{														#given ricker _a ricker_b and Process errors#
	y<-x*exp(a-b*x+proc_error)#
#
return(y)#
}#
#
ricker_predator<-function(x,a,b,q,p,proc_error)				#a function to calculate the return associated with any spawning stock size #
{															#given ricker _a ricker_b and Process errors#
	y<-x*exp(a-b*x-q*p+proc_error)							#incorperating predator effects#
#
return(y)#
}#
#Plotting Sub#
#
second_axis<-function(x,y1,y1_1,y1_2,y2,ax_1,ax_2)#
{#
	par(mar=c(5, 12, 4, 4) + 0.1)#
	plot(x,y1,type="b",col="black",lty=1,lwd=1.2,axes=T,xlab="", ylab="", main="", ylim=c(0,max(y1,y1_1,y1_2,na.rm=T)))#
	lines(x,y1_1,type="b",col="dark red")#
	lines(x,y1_2,type="b",col="dark green")#
	axis(2, ylim=c(0,max(y1,na.rm=T)),col="black",lwd=2)#
	mtext(2,text=ax_1,line=2)#
#
	#plot Harvest Rate vs Populations Extinct n second axis#
	par(new=T)#
	plot(x,y2,type="l",col="red",lty=1,lwd=1.2,axes=F,xlab="", ylab="", main="")#
	axis(2, ylim=c(0,max(y2,na.rm=T)),lwd=2,line=3.5, col="red")#
	mtext(2,text=ax_2,line=5.5, col="red")#
}#
#
##########################################################################################################
#Graphics - Subs#
##########################################################################################################
#Main#
##########################################################################################################
#
#read in marine mortality data #
fn<-"COHO_data_Fraser.csv"								#assign filename to a variable #
coho_time_series<-read.csv(fn,header=T)			#read coho timeseries into model#
#Set parameters#
#
years<-coho_time_series$Year 					#Year of observations#
s_obs<-coho_time_series$COHO_Spawners			#Spwaning Stock (DFO Data)#
hr_obs<-coho_time_series$est_ER					#estimated Harvest Rates (DFO Data)#
pred_obs<-coho_time_series$Piniped				#estimated predator populations size (DFO Data - Ben Nelson Model)#
n_years<-length(years)#
k<-3#
#
r_derived<-s_obs/(1-hr_obs)						#reivation of recruitments (by Brood Year given pawners and HR from DFO DATA)#
r_by<-r_derived[(k+1):n_years]#
s_by<-s_obs[1:(n_years-k)]#
pred_by<-pred_obs[1:(n_years-k)]#
#
LNRS<-log(r_by/s_by)#
l_normal<-lm(LNRS~s_by)							#total BS fit#
l_pred<-lm(LNRS~s_by+pred_by)					#quite good fit#
#
ricker_a_p<-l_pred$coeff[1]#
ricker_b_p<- -l_pred$coeff[2]#
ricker_q_p<- -l_pred$coeff[3]#
#
ricker_a<-l_normal$coeff[1]#
ricker_b<- -l_normal$coeff[2]#
#
s_vec<-seq(0,1.25*max(s_obs,na.rm=T),length=200)#
r_vec_p_low<-ricker_predator(s_vec,ricker_a_p,ricker_b_p,ricker_q_p,pred_obs[10],0)	#
r_vec_p_high<-ricker_predator(s_vec,ricker_a_p,ricker_b_p,ricker_q_p,pred_obs[35],0)	#
r_vec<-ricker_simple(s_vec,ricker_a,ricker_b,0)#
#
r_pred_l<-ricker_simple(s_by,ricker_a,ricker_b,0)#
r_pred_p<-ricker_predator(s_by,ricker_a_p,ricker_b_p,ricker_q_p,pred_by,0)	#
#
par(mfcol=c(1,2))#
plot(s_by,r_by, ylim=c(0,1.25*max(r_by)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="Recruits",xlab="Spawners")#
points(s_by,r_pred_p,pch=3,col="red")#
#points(s_by,r_pred_l,pch=2,col="green")#
lines(s_vec,r_vec_p_low,col="red",lty=2)#
lines(s_vec,r_vec_p_high,col="red",lty=3)#
#lines(s_vec,r_vec,col="green",lty=2)#
#
plot(s_by,LNRS, ylim=c(0,1.25*max(LNRS)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="ln(Recruits/Spawners)",xlab="Spawners")#
points(s_by,log(r_pred_p/s_by),pch=3,col="red")#
lines(s_vec,log(r_vec_p_low/s_vec),col="red",lty=2)#
lines(s_vec,log(r_vec_p_high/s_vec),col="red",lty=3)#
n_eq<-1000#
n_policy<-1000#
#Generate Recruitment deviations (optional)#
wt<-rnorm(n_years,0,0.6)						#normaly distributed proicess error#
#
#Initialize populations#
hr<-seq(0,1,length=n_policy)#
s_eq<-rep(0,length=n_policy)#
r_eq<-rep(0,length=n_policy)#
yt_eq<-rep(0,length=n_policy)#
#
for(p in 1:n_policy)#
{#
#
s<-rep(s_obs,length=n_eq)					#initialize our spawning stock #
r<-rep(NA,length=n_eq)						#vector to hold our recruits#
yt<-rep(NA,length=n_eq)						#vector to hold our yeild#
#
for(y in (k+1):n_eq)								#generate a population given HR and other parameters#
{#
	r[y]<-ricker_predator(s[y-k],ricker_a_p,ricker_b_p,ricker_q_p,pred_obs[35],0)		#generate a recruitments#
	s[y]<-r[y]*(1-hr[p])										#spawners are the ones who survive our fishery#
	yt[y]<-r[y]*hr[p]											#catch are the ones who dont#
#
}#
s_eq[p]<-s[n_eq]#
r_eq[p]<-r[n_eq]#
yt_eq[p]<-yt[n_eq]#
#
}#
#
plot(hr,s_eq, ylab="Numbers of Coho",xlab="Harvest Rate", type="l", col="blue")#
lines(hr,yt_eq,col="blue",lty=2)#
for(p in 1:n_policy)#
{#
#
s<-rep(s_obs,length=n_eq)					#initialize our spawning stock #
r<-rep(NA,length=n_eq)						#vector to hold our recruits#
yt<-rep(NA,length=n_eq)						#vector to hold our yeild#
#
for(y in (k+1):n_eq)								#generate a population given HR and other parameters#
{#
	r[y]<-ricker_predator(s[y-k],ricker_a_p,ricker_b_p,ricker_q_p,pred_obs[10],0)		#generate a recruitments#
	s[y]<-r[y]*(1-hr[p])										#spawners are the ones who survive our fishery#
	yt[y]<-r[y]*hr[p]											#catch are the ones who dont#
#
}#
s_eq[p]<-s[n_eq]#
r_eq[p]<-r[n_eq]#
yt_eq[p]<-yt[n_eq]#
#
}#
#
plot(hr,s_eq, ylab="Numbers of Coho",xlab="Harvest Rate", type="l", col="red")#
lines(hr,yt_eq,col="red",lty=2)#
#Simulate population dynamics
exp(2)
1exp(2)
exp(-2)
1-exp(2)
1-exp(-2)
ls()
reptoRlist = function(fn)#
{#
ifile=scan(fn,what="character",flush=T,blank.lines.skip=F,quiet=T)#
idx=sapply(as.double(ifile),is.na)#
vnam=ifile[idx] #list names#
nv=length(vnam) #number of objects#
A=list()#
ir=0#
for(i in 1:nv)#
	{#
		ir=match(vnam[i],ifile)#
		if(i!=nv) irr=match(vnam[i+1],ifile) else irr=length(ifile)+1 #next row#
		dum=NA#
		if(irr-ir==2) dum=as.double(scan(fn,skip=ir,nlines=1,quiet=T,what=""))#
		if(irr-ir>2) dum=as.matrix(read.table(fn,skip=ir,nrow=irr-ir-1,fill=T))#
#
		if(is.numeric(dum))#Logical test to ensure dealing with numbers#
		{#
		A[[vnam[i]]]=dum#
		}#
	}#
return(A)#
}#
#
gletter = function(i=1)#
{#
	usr=par("usr"); inset.x=0.05*(usr[2]-usr[1]); inset.y=0.05*(usr[4]-usr[3])#
	text(usr[1]+inset.x,usr[4]-inset.y,paste("(",letters[i],")",sep=""),cex=1.,font=1)#
}
get.ce	<-	function(fi,si,ue=seq(0,0.999,length=200))#
{	#This function returns the equilibrium catch for a given exploitation rate#
	#Args:	fi <- fmsy for stock i#
	#		si <- Smsy for stock i#
	#		ue <- vector of equilibrium exploitation rates#
	fe		<- -log(1-ue)#
	ce		<- (1+fi-exp(-fi)-fe)/(1-exp(-fi))*si*(exp(fe)-1)#
	ce[ce<0]	<- NA#
	return(ce)#
}#
#
equilibrium	<-	function()#
{#
	n	<- 200#
	ue	<- seq(0,max(ud),length=n)#
	ce	<- mapply(get.ce,fi,si,MoreArgs=list(ue=ue))#
	Ye	<- rowSums(ce,na.rm=T)	#Total yield summed over all extant stocks#
	fn1	<- function(ui){pof<-ue; pof[pof<ui] <- 0; pof[pof!=0]=1; return(pof)}#
	fn2	<- function(ud){poe<-ue; poe[poe<ud] <- 0; poe[poe!=0]=1; return(poe)}#
	pof	<- rowSums(sapply(ui,fn1))/N#
	poe	<- rowSums(sapply(ud,fn2))/N#
	i1	<- match(unique(pof),pof)#
	spfn1	<- spline(ue,pof,n=n)#
	spfn2	<- spline(ue,poe,n=n)#
	matplot(ue,ce,type="l")#
	plot(ue,Ye,lwd=2,type="l")#
	#Still struggling with a way to plot the pareto curve.#
	pof	<- pareto(ui,ue)#
	plot(Ye/max(Ye),1-spfn1$y,type="o")#
	plot(Ye/max(1),1-rowSums(pof)/N,type="l",ylab="P(not overfished)",xlab="Total yield")#
}#
#
pareto	<- function(ui,ue)#
{#
	Vi		<- 0.01*ui		#expected variance#
	alpha	<- -ui*(Vi-ui+ui^2)/Vi#
	betta	<- alpha/ui-alpha#
	fn	<- function(alpha,betta) {pbeta(ue,alpha,betta)}#
	p	<- mapply(fn,alpha,betta)#
	n	<- length(ui)#
	matplot(ue,p,type="l")#
	plot(ue,rowSums(p)/n,col="green")#
	return(p)#
}
fake.data	<-	function(N=12,nyr=50,k=4,f1=0.3,f2=0.85,seed=12345)#
{	#This function generates fake multistock data for simulation testing#
	ai	<-	uopt-log(1-uopt)#
	bi	<-	uopt/sopt#
	ft	<-	f1 + (f2-f1)*sin( (1:nyr-1)/(nyr-1)*pi)^2#
	xt	<-	matrix(0,nrow=nyr,ncol=N)#
	set.seed(seed)#
	tau	<-	0.5#
	sig	<-	0.5#
	wt	<-	rnorm(nyr-k,0,tau)#
	vt	<-	matrix(rnorm(N*nyr,0,sig),	nrow=nyr,ncol=N)#
	ix	<-	matrix(rbinom(N*nyr,1,0.15),	nrow=nyr,ncol=N) #p=proportion of data missing#
	xt[1:k,]	<- 	log(runif(N*k,0.1*ai/bi,ai/bi))#
	for(i in (k+1):nyr)#
	{#
		xt[i,]	 <-	xt[i-k,] + ai - ft[i-k] - bi*exp(xt[i-k,]) + wt[i-k]#
	}#
	#Observation model#
	st		<- exp(xt + vt)#
	st[ix==1]	<- NA#
	#Write fake data file.#
	fn	<-	"FakeData.dat"#
	write("#Fake Data",fn)#
	write("#nstocks, nyrs, k",fn,append=T)#
	write(c(N,nyr,k),fn,append=T,sep="\t")#
	write("#Ft",fn,append=T)#
	write(ft,fn,append=T)#
	write("#Escapement table (number of spawners)",fn,append=T)#
	write.table(st,fn,append=T,na="0",row.names=F,col.names=F,sep="\t")#
	matplot(1:nyr,st,type="l")#
#
	return(st)#
}#
#
estimation	<-	function(datafile="FakeData.dat", get.std=F)#
{	# This function calls the MSAM.exe program to estimate#
	# model parameters.  #
	# NB. the MSAM.exe & datafile must be in the same directory#
	# as this R-code.#
	#fn.call	<- paste("MSAM.exe -ind",datafile,"-nox -maxfn 2000")#
	fn.call	<- paste("./MSAM -ind",datafile,"-nox -maxfn 500,1500,10000 -est")#
	if(get.std)fn.call <- paste("./MSAM -ind",datafile,"-nox -maxfn 500,1500,10000")#
	system(fn.call)#
	A	<- reptoRlist("MSAM.rep")#
	if(get.std){#
		tmp	<- matrix(scan("msam.std",what="character",skip=1),ncol=4,byrow=T)	#std file#
		A$std <- as.double(tmp[,4])#
	}#
	#qqnorm(A$vt[A$vt!=0])#
	return(A)#
}#
#
monte.carlo<-function(n=1)#
{#
	iseed=seq(999,by=2, length=n)#
	uopt<-sopt<-NULL#
	for(i in iseed){#
		simulation.model(i, 0.05, F)#
		A=estimation()#
		uopt=rbind(uopt, A$uopt)#
		sopt=rbind(sopt, A$sopt)#
	}#
	boxplot(uopt, xlab="Stock number", ylab="U*", col="grey")#
	points(ui, pch=19, col=2)#
	boxplot(sopt, ylim=c(0, 2), xlab="Stock number", ylab="S*", col="grey")#
	points(si,pch=19, col=2)#
}#
#
srcurve<-function()#
{#
	s <- seq(0, 2, length=100)#
	fn <- function(s) s*exp(ai-bi*s)#
	r <- t(sapply(s, fn))#
	matplot(s, r, type="l", col="grey", ylab="Recruits", xlab="Escapement")#
	matplot(s/si, t(t(r)/ri), type="l", col="grey", ylab="R/R*", xlab="S/S*")#
}#
#
plot.sr <- function(A)#
{#
	#This function plots the sr curves#
	#for each of the n stocks#
	par(mfcol=c(6,5),mar=c(0,0,0,0),yaxt="n",xaxt="n",oma=c(4,4,1,1))#
	par(cex.main=0.8)#
	#par(col.axis="grey", col.lab="grey")#
	n=dim(A$St)[2]  #number of stocks#
	nyr=dim(A$St)[1]#
	byr=1:(nyr-k)	#
	i=1#
    fn<-function(i){#
		st=A$St[byr, i]; st[st==0]=NA#
		rt=A$Rt[byr+k, i]; rt[st==NA]=NA#
		ss=seq(0,max(st, na.rm=T),length=250)#
		rr=ss*(exp(A$ai[i]-A$bi[i]*ss))#
		plot(st,rt, #
			xlim=c(0, max(st, na.rm=T)), ylim=c(0, 1.2*max(rt, na.rm=T)),#
			xlab="", ylab="", pch=20, col="black")#
		abline(0, 1, lty=2)#
		lines(ss, rr)#
		title(main=sox.stocks[i], line=-1)#
		#lines(ss, ss*exp(ai[i]-bi[i]*ss), col=2)  #for fake data only#
	}#
	sapply(1:n, fn)#
	mtext("Escapement", 1, outer=T, line=1.4, cex=2)#
	mtext("Recruitment", 2, outer=T, las=0, line=1, cex=2)#
}#
plot.summary	<-	function(A)#
{#
	#A is a list object that contains the estimation results#
	op	<- par(no.readonly=T)#
	par(mfcol=c(2,2))#
	n	<-	dim(A$St)[2]#
	clr	<-	rainbow(n)#
	ropt	<-	A$sopt*exp(A$ai-A$bi*A$sopt)#
	S	<-	seq(0,2,length=100)#
	fn	<-	function(S) S*exp(A$ai-A$bi*S*A$sopt)#
	R	<-	t(sapply(S,fn))#
	matplot(S,R,type="l",xlab="S/S*",ylab="R/R*",col=clr)#
	gletter(1)#
	barplot(A$uopt,col=clr,ylim=c(0,1),xlab="Stock",ylab="U*",names.arg=paste(1:n))#
	lines(ui)#
	matplot(log(A$St[A$St!=0]),log(A$Xt[A$St!=0]),col=1,pch=5,cex=0.5,xlab="ln(Observed St)",ylab="ln(Predicted St)")#
	abline(a=0,b=1)#
	qqnorm(A$vt[A$vt!=0],col=1)#
	qqline(A$vt[A$vt!=0])#
	par(op)#
}#
#
get.ce	<-	function(ui,si,ue=seq(0,0.999,length=200))#
{	#This function returns the equilibrium catch for a given exploitation rate#
	#Args:	ui <- umsy for stock i#
	#		si <- Smsy for stock i#
	#		ue <- vector of equilibrium exploitation rates#
	fe		<- -log(1-ue)#
	fi		<- -log(1-ui)#
	ce		<- (1+fi-exp(-fi)-fe)/(1-exp(-fi))*si*(exp(fe)-1)#
	ce[ce<0]	<- NA#
	return(ce)#
}#
#
pareto		<- 	function(A)#
{#
	ue		<- seq(0,1,length=200)#
	ui		<- A$uopt#
	n		<- dim(A$St)[2]#
	clr	<-	rainbow(n)#
	Vi		<- A$std[1:n]^2#
	alpha	<- -ui*(Vi-ui+ui^2)/Vi#
	betta	<- alpha/ui-alpha#
	fn	<- function(alpha,betta) {pbeta(ue,alpha,betta)}#
	p	<- mapply(fn,alpha,betta)#
	n	<- length(ui)#
	matplot(ue,p,type="l",col="grey", xlab="Exploitation rate (Ue)", #
	ylab="Probability of overfishing")#
	plot(ue,rowSums(p)/n*length(ui),col="grey",type="l",lwd=2,xlab="Exploitation rate (Ue)", #
	 	ylab="Number of stocks overfished")#
	return(p)#
}#
#
pareto2		<- 	function(A)#
{#
	ue		<- seq(0,1,length=200)#
	ud		<<- 1-exp(-A$ai)#
	n		<- dim(A$St)[2]#
	clr	<-	rainbow(n)#
	nr		<- length(A$std)#
	Vi		<<- A$std[(nr-n+1):nr]^2#
	alpha	<- -ud*(Vi-ud+ud^2)/Vi#
	betta	<- alpha/ud-alpha#
	print(ud)#
	fn	<- function(alpha,betta) {pbeta(ue,alpha,betta)}#
	p	<- mapply(fn,alpha,betta)#
	n	<- length(ud)#
	matplot(ue,p,type="l",col="grey", xlab="Exploitation rate (Ue)", #
	ylab="Extinction risk")#
	plot(ue,rowSums(p, na.rm=T),col="grey",type="l",lwd=2,xlab="Exploitation rate (Ue)", #
	 	ylab="Number of stocks at risk of extinction")#
	return(p)#
}#
#
equilibrium	<-	function(A)#
{  #
	par(mfcol=c(1, 1), cex.lab=1.5, cex.axis=1.25, las=1, col.axis="grey", col.lab="grey")#
	n	<- 200				#number of discrete intervals #
	ue	<- seq(0,max(1),length=n)	#exploitation rate#
	ce	<<- mapply(get.ce,A$uopt,A$sopt,MoreArgs=list(ue=ue))/1000#
	Ye	<<- rowSums(ce,na.rm=T)	#Total yield summed over all extant stocks#
	plot(ue,Ye/max(Ye)*1.2*max(ce, na.rm=T),type="l", lwd=3, col="grey"#
	,xlab="Exploitation rate (ue)",ylab="Equilibrium yield (1000s)", bty="l")#
	matlines(ue,ce, col="grey") #
	legend("topleft", "Relative total yield", lty=1, col="grey", lwd=3, bty="n", text.col="grey")#
	pof	<<- pareto(A)#
	pof2	<<- pareto2(A)#
	#plot(Ye/max(Ye),1-spfn1$y,type="o")#
	plot(Ye/max(Ye)*100,rowSums(pof)/length(A$uopt),type="l", lwd=3, col="grey"#
	,ylab="P(overfished)",xlab="Percent of maximum yield")#
	#lines(Ye/max(Ye)*100,rowSums(pof2, na.rm=T)/length(A$uopt),type="l", lwd=3, lty=2, col="grey")#
}
COHO_CU<-estimation("IFRCOHODataCU.dat", T)#
COHO_SUB<-estimation("IFRCOHODataSUBS.dat", T)
COHO_CU<-estimation("IFRCOHODataCU.dat", T)#
COHO_SUB<-estimation("IFRCOHODataSUBS.dat", T)
COHO_SUB
COHO_SUB$ai
COHO_CU$ai
pred_obs
rm(list=ls())															#clear the crud out of local memory#
set.seed(999)															#all use same random numbers#
setwd("/Users/mikehawkshaw/Desktop/Fish_505_Example/Fish_505")			#it makes reading and writing files easier if you're in the right directory										#set a working directory#
##########################################################################################################
#Sub Functions#
##########################################################################################################
#Dynamics - Subs#
#
#RICKER REC SUB#
ricker_simple<-function(x,a,b,proc_error)				#a function to calculate the return associated with any spawning stock size #
{														#given ricker _a ricker_b and Process errors#
	y<-x*exp(a-b*x+proc_error)#
#
return(y)#
}#
#
#RICKER REC SUB#
ricker_predator<-function(x,a,b,q,p,proc_error)				#a function to calculate the return associated with any spawning stock size #
{															#given ricker _a ricker_b and Process errors#
	y<-x*exp(a-b*x-q*p+proc_error)							#incorperating predator effects#
#
return(y)#
}#
#
#Plotting Sub#
#
second_axis<-function(x,y1,y1_1,y1_2,y2,ax_1,ax_2)#
{#
	par(mar=c(5, 12, 4, 4) + 0.1)#
	plot(x,y1,type="b",col="black",lty=1,lwd=1.2,axes=T,xlab="", ylab="", main="", ylim=c(0,max(y1,y1_1,y1_2,na.rm=T)))#
	lines(x,y1_1,type="b",col="dark red")#
	lines(x,y1_2,type="b",col="dark green")#
	axis(2, ylim=c(0,max(y1,na.rm=T)),col="black",lwd=2)#
	mtext(2,text=ax_1,line=2)#
#
	#plot Harvest Rate vs Populations Extinct n second axis#
	par(new=T)#
	plot(x,y2,type="l",col="red",lty=1,lwd=1.2,axes=F,xlab="", ylab="", main="")#
	axis(2, ylim=c(0,max(y2,na.rm=T)),lwd=2,line=3.5, col="red")#
	mtext(2,text=ax_2,line=5.5, col="red")#
}#
#
##########################################################################################################
#Graphics - Subs#
##########################################################################################################
#Main#
##########################################################################################################
#
#read in marine mortality data #
fn<-"COHO_data_Fraser.csv"						#assign filename to a variable #
coho_time_series<-read.csv(fn,header=T)			#read coho timeseries into model#
#Set parameters#
#
years<-coho_time_series$Year 					#Year of observations#
s_obs<-coho_time_series$COHO_Spawners			#Spwaning Stock (DFO Data)#
hr_obs<-coho_time_series$est_ER					#estimated Harvest Rates (DFO Data)#
pred_obs<-coho_time_series$Piniped				#estimated predator populations size (DFO Data - Ben Nelson Model)#
n_years<-length(years)							#how many years of data is there#
k<-3											#interior fraser coho life history is very specific
n_years
r_derived<-s_obs/(1-hr_obs)						#derivation of recruitments (by Brood Year given pawners and HR from DFO DATA)#
r_by<-r_derived[(k+1):n_years]#
s_by<-s_obs[1:(n_years-k)]#
pred_by<-pred_obs[1:(n_years-k)]#
#
LNRS<-log(r_by/s_by)#
l_normal<-lm(LNRS~s_by)							#total BS fit#
l_pred<-lm(LNRS~s_by+pred_by)					#quite good fit
l_pred
ricker_a_p<-l_pred$coeff[1]#
ricker_b_p<- -l_pred$coeff[2]#
ricker_q_p<- -l_pred$coeff[3]#
#
ricker_a<-l_normal$coeff[1]#
ricker_b<- -l_normal$coeff[2]
r_pred_l<-ricker_simple(s_by,ricker_a,ricker_b,0)#
r_pred_p<-ricker_predator(s_by,ricker_a_p,ricker_b_p,ricker_q_p,pred_by,0)
s_vec<-seq(0,1.25*max(s_obs,na.rm=T),length=200)#
r_vec_p_low<-ricker_predator(s_vec,ricker_a_p,ricker_b_p,ricker_q_p,pred_obs[10],0)	#
r_vec_p_high<-ricker_predator(s_vec,ricker_a_p,ricker_b_p,ricker_q_p,pred_obs[35],0)	#
r_vec<-ricker_simple(s_vec,ricker_a,ricker_b,0)
s_vec<-seq(0,1.25*max(s_obs,na.rm=T),length=200)#
r_vec_p_low<-ricker_predator(s_vec,ricker_a_p,ricker_b_p,ricker_q_p,pred_obs[10],0)	#
r_vec_p_high<-ricker_predator(s_vec,ricker_a_p,ricker_b_p,ricker_q_p,pred_obs[35],0)	#
r_vec<-ricker_simple(s_vec,ricker_a,ricker_b,0)#
#
r_pred_l<-ricker_simple(s_by,ricker_a,ricker_b,0)#
r_pred_p<-ricker_predator(s_by,ricker_a_p,ricker_b_p,ricker_q_p,pred_by,0)	#
#
par(mfcol=c(1,2))#
plot(s_by,r_by, ylim=c(0,1.25*max(r_by)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="Recruits",xlab="Spawners")#
points(s_by,r_pred_p,pch=3,col="red")#
points(s_by,r_pred_l,pch=2,col="green")#
lines(s_vec,r_vec_p_low,col="red",lty=2)#
lines(s_vec,r_vec_p_high,col="red",lty=3)#
#lines(s_vec,r_vec,col="green",lty=2)#
#
plot(s_by,LNRS, ylim=c(0,1.25*max(LNRS)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="ln(Recruits/Spawners)",xlab="Spawners")#
points(s_by,log(r_pred_p/s_by),pch=3,col="red")#
lines(s_vec,log(r_vec_p_low/s_vec),col="red",lty=2)#
lines(s_vec,log(r_vec_p_high/s_vec),col="red",lty=3)
par(mfcol=c(1,2))#
plot(s_by,r_by, ylim=c(0,1.25*max(r_by)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="Recruits",xlab="Spawners")#
points(s_by,r_pred_p,pch=3,col="red")#
points(s_by,r_pred_l,pch=2,col="green")#
lines(s_vec,r_vec_p_low,col="red",lty=2)#
lines(s_vec,r_vec_p_high,col="red",lty=3)#
#lines(s_vec,r_vec,col="green",lty=2)#
#
plot(s_by,LNRS, ylim=c(0,1.25*max(LNRS)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="ln(Recruits/Spawners)",xlab="Spawners")#
points(s_by,log(r_pred_p/s_by),pch=3,col="red")#
points(s_by,log(r_pred_l/s_by),pch=2,col="green")#
lines(s_vec,log(r_vec_p_low/s_vec),col="red",lty=2)#
lines(s_vec,log(r_vec_p_high/s_vec),col="red",lty=3)
par(mfcol=c(1,2))#
plot(s_by,r_by, ylim=c(0,1.25*max(r_by)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="Recruits",xlab="Spawners")#
#points(s_by,r_pred_p,pch=3,col="red")#
#points(s_by,r_pred_l,pch=2,col="green")#
#lines(s_vec,r_vec_p_low,col="red",lty=2)#
#lines(s_vec,r_vec_p_high,col="red",lty=3)#
#lines(s_vec,r_vec,col="green",lty=2)#
#
plot(s_by,LNRS, ylim=c(0,1.25*max(LNRS)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="ln(Recruits/Spawners)",xlab="Spawners")#
#points(s_by,log(r_pred_p/s_by),pch=3,col="red")#
#points(s_by,log(r_pred_l/s_by),pch=2,col="green")#
#lines(s_vec,log(r_vec_p_low/s_vec),col="red",lty=2)#
#lines(s_vec,log(r_vec_p_high/s_vec),col="red",lty=3)
par(mfcol=c(1,2))#
plot(s_by,r_by, ylim=c(0,1.25*max(r_by)),xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="Recruits",xlab="Spawners")#
#points(s_by,r_pred_p,pch=3,col="red")#
#points(s_by,r_pred_l,pch=2,col="green")#
#lines(s_vec,r_vec_p_low,col="red",lty=2)#
#lines(s_vec,r_vec_p_high,col="red",lty=3)#
#lines(s_vec,r_vec,col="green",lty=2)#
#
plot(s_by,LNRS,xlim=c(0,1.25*max(s_obs,na.rm=T)),ylab="ln(Recruits/Spawners)",xlab="Spawners")#
#points(s_by,log(r_pred_p/s_by),pch=3,col="red")#
#points(s_by,log(r_pred_l/s_by),pch=2,col="green")#
#lines(s_vec,log(r_vec_p_low/s_vec),col="red",lty=2)#
#lines(s_vec,log(r_vec_p_high/s_vec),col="red",lty=3)
AIC
AIC(l_normal,l_pred)
plot(AIC(l_normal,l_pred))
library(lmtest)
?lmtest
lmtest()
lmtest
plot(lrtest(l_normal,l_pred))
(lrtest(l_normal,l_pred))
?lrtest
lm
l_normal
stats(l_normal)
stat(l_normal)
str(l_normal)
plot(l_nomal)
plot(l_normal)
plot(l_pred)
